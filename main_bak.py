from skidl import *
import matplotlib.pyplot as plt
import PySpice
import numpy as np

def battery_plus():
    
    #In this function, the assumption is this battery, B2, generates current in the same direction
    V_a = abs(float(input("What is the voltage of B1 in Volts: ")))
    V_b = abs(float(input("What is the voltage of B2 in Volts: ")))
    R_1 = abs(float(input("What is the resistance of R1 in Ohms: ")))
    R_2 = abs(float(input("What is the resistance of R2, in parallel with B2, in Ohms: ")))
    R_3 = abs(float(input("What is the resistance of R3, in series with B2, in Ohms:")))
    #There are three different currents in 3 total loops, but TWO different currents are generated by two different batteries
    #Use Kirchoff's Voltage Rule to produce 3 equations
    #1. V_a - I_1*R_1 - I_2*R_2 = 0, 2. V_a - I_1*R_1 - I_3*R_3 + V_b = 0, 3. V_b + I_2*R_2 - I_3*R_3 = 0
    #Using Kirchoff's Junction Rule, equation 4 is I_1 = I_2 + I_3
    #Substitute equation 4 into equation 2 through I_1, solve for I_2 in terms of I_3 from eq 3, and reinsert in equation 2
    #Algebra from there
    I_3 = (V_a*R_2 + V_b*R_2 - V_b*R_1)/(R_1*R_2 + R_2*R_3 + R_1*R_3)
    #With I_3 numerically defined, I_2 is easily solvable
    I_2 = I_3*(R_3/R_2) - (V_b/R_2)
    #Just for reference, I_1 = (V_a/R_1) - I_3*(R_3/R_1)
    #Remember, we want the current through the lone resistor, which is I_2
    
    return I_2

def battery_moinus():
    
    #In this function, the asumption is this battery, B2, generates current in the opposite direction
    V_a = abs(float(input("What is the voltage of B1 in Volts: ")))
    V_b = abs(float(input("What is the voltage of B2 in Volts: ")))
    R_1 = abs(float(input("What is the resistance of R1 in Ohms: ")))
    R_2 = abs(float(input("What is the resistance of R2, in parallel with B2, in Ohms: ")))
    R_3 = abs(float(input("What is the resistance of R3, in series with B2, in Ohms:")))
    #There are three different currents in 3 total loops, but TWO different currents are generated by two different batteries
    #Use Kirchoff's Voltage Rule to produce 3 equations
    #1. V_a - I_1*R_1 - I_2*R_2 = 0, 2. V_a - I_1*R_1 - I_3*R_3 + V_b = 0, 3. V_b + I_2*R_2 - I_3*R_3 = 0
    #Using Kirchoff's Junction Rule, equation 4 is I_2 = I_1 + I_3
    #Rearrange equation 4 to I_3 = I_2 - I_1, and then substitute that into equation 3 to define I_1 in terms of I_2
    #Now substitute that into equation 1 to define I_2 in terms of known variables
    I_2 = (V_a*R_3 + V_b*R_1)/(R_1*R_2 + R_1*R_3 + R_2*R_3)
    
    return I_2

def capacitor():
    
    #The capacitor is in parallel with R_2. The capacitance, C, is known.
    V = abs(float(input("What is the voltage of B1 in Volts: ")))
    R_1 = abs(float(input("What is the resistance of R1, in series with V, in Ohms: ")))
    R_2 = abs(float(input("What is the resistance of R2, in parallel to R3, in Ohms: ")))
    C = abs(float(input("What is the capacitance of the capacitor, in Farads: ")))
    #First, apply V = Q/C, and when charging, the capacitor subtracts from the voltage
    #The 2 equations from the KVR are 1. V - I_1*R_1 - I_2*R_2 = 0, 2. V - I_1*R_1 - Q/C = 0
    #Using the KJR, the final equation needed is I_1 = I_2 + I_c
    #I_c is the current flowing through the capacitor and it behaves opposite I_2.
    #Remember I = dQ/dt, the derivative of charge with respect to time
    #After algebra and certain integrations...
    I_2 = (V/R_1)*(1-np.exp(-((R_1 + R_2)/(C*R_1*R_2))))
    
    return I_2
#def inductor():
def resistor():
    
    V = abs(float(input("What is the voltage of B1 in Volts: ")))
    R_1 = abs(float(input("What is the resistance of R1, in series with V, in Ohms: ")))
    R_2 = abs(float(input("What is the resistance of R2, in parallel to R3, in Ohms: ")))
    R_3 = abs(float(input("What is the resistance of R3, in parallel to R2, in Ohms: ")))
    #Use Kirchoff's Junction Rule, I_1 = I_2 + I_3
    #Kirchoff's Voltage Rule yields the rest of the equations.
    #The equations are 1. V - I_1*R_1 - I_2*R_2 = 0; 2. V - I_1*R_1 - I_3*R_3 = 0; 3. I_1 = I_2 + I_3
    I_1 = (V*R_2 + V*R_3)/(R_1*R_2 + R_2*R_3 + R_1*R_3)
    I_2 = (V - (I_1*R_1))/R_2
    
    return I_2

def printBoard(letter, device):
    print(" ----------------------------------------- ")
    print(" |                  |                    | ")
    print("(+) V1              z R1             {0}1 ({1}) ".format(letter, device))
    print(" |                  |                    | ")
    print(" -----------------------------------------")

def testCircuit():
    pass
    # reset()

    # vs = V(ref='VS', dc_value = 1 @ u_V)  # Create a voltage source named "VS" with an initial value of 1 volt.
    # r1 = R(value = 1 @ u_kOhm)            # Create a 1 Kohm resistor.
    # vs['p'] += r1[1]       # Connect one end of the resistor to the positive terminal of the voltage source.
    # gnd += vs['n'], r1[2]  # Connect the other end of the resistor and the negative terminal of the source to ground.

    # # Simulate the circuit.
    # circ = generate_netlist()              # Translate the SKiDL code into a PyCircuit Circuit object.
    # sim = circ.simulator()                 # Create a simulator for the Circuit object.
    # dc_vals = sim.dc(VS=slice(0, 1, 0.1))  # Run a DC simulation where the voltage ramps from 0 to 1V by 0.1V increments.

    # # Get the voltage applied to the resistor and the current coming out of the voltage source.
    # voltage = dc_vals[node(vs['p'])]       # Get the voltage applied by the positive terminal of the source.
    # current = -dc_vals['VS']               # Get the current coming out of the positive terminal of the voltage source.

    # # Print a table showing the current through the resistor for the various applied voltages.
    # print('{:^7s}{:^7s}'.format('V', ' I (mA)'))
    # print('='*15)
    # for v, i in zip(voltage.as_ndarray(), current.as_ndarray()*1000):
    #     print('{:6.2f} {:6.2f}'.format(v, i))

    # # Create a plot of the current (Y coord) versus the applied voltage (X coord).
    # figure = plt.figure(1)
    # plt.title('Resistor Current vs. Applied Voltage')
    # plt.xlabel('Voltage (V)')
    # plt.ylabel('Current (mA)')
    # plt.plot(voltage, current*1000) # Plot X=voltage and Y=current (in milliamps, so multiply it by 1000).
    # plt.show()

if __name__ == "__main__":
    #There is a simple circuit with one battery (B1) and two items in parallel. There is nothing else outside the parallel
    #Occupying one route is a resistor (R1). Using the menu, you get to choose the item across the resistor
    #Then the program will calculate the current flowing through the resistor as a function of time
    #As you can imagine, depending on what you choose...the current will behave differently
    #MENU--1: Battery w/ positive current; 2: Battery w/ negative current; 3: Capacitor; 4: Inductor; 5: Resistor; 6: Just Wire
    
    item_block = abs(int(input("Enter a number on the menu: ")))
    
    if item_block == 1:
        print("The current across R_2 is",battery_plus(),"Amperes.")
    if item_block == 2:
        print("The current across R_2 is",battery_minus(),"Amperes.")
    
    #if item_block == 3:
    
    #if item_block == 4:
        
    if item_block == 5:
        print("The current across R_2 is",resistor(),"Amperes.")
        
    if item_block == 6:
        print("")
        print("The current across R_2 is 0 Amperes.")
        #Most of the current of the circuit will attempt to pass through the path with the least resistance
        #If there is no resistance in the parallel opposite R_2, the current will skip it entirely, leaving I_2 = 0.
        
    else:
        print("Invalid input. Rerun the program.")
    
    # printBoard("C", "=")
    # printBoard("I", "^")
    testCircuit()
# >>>>>>> 32809816487c1f8b857db50c4d67d30c568fdfc5
